<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFT WASM Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }

        .tab:hover {
            color: #667eea;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-section.dragover {
            border-color: #764ba2;
            background: #e8ebff;
            transform: scale(1.02);
        }

        input[type="file"] {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 15px 30px;
            background: #667eea;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .file-input-label:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .file-info {
            margin-top: 20px;
            color: #666;
            font-size: 0.95em;
        }

        .image-preview {
            margin-top: 20px;
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .image-preview-container {
            display: none;
            margin-top: 20px;
        }

        .image-preview-container.active {
            display: block;
        }

        .url-input-section {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 10px;
            border: 2px solid #e0e4ff;
        }

        .url-input-section h4 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .url-input-group {
            display: flex;
            gap: 10px;
        }

        .url-input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            font-family: inherit;
            transition: border-color 0.3s ease;
        }

        .url-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 500;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            display: block;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            display: block;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
            display: block;
        }

        .results-section {
            margin-top: 30px;
            display: none;
        }

        .results-section.active {
            display: block;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .result-card {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #e0e4ff;
        }

        .result-card.full-width {
            grid-column: 1 / -1;
        }

        .result-card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .stats {
            margin: 15px 0;
            font-size: 0.95em;
            color: #555;
        }

        .stats strong {
            color: #333;
        }

        .preview {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #333;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .fft-canvas {
            width: 100%;
            height: 300px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-top: 15px;
        }

        .download-btn {
            display: inline-block;
            padding: 10px 20px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        .download-btn:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .btn {
            padding: 12px 25px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .btn:hover:not(:disabled) {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .results-grid {
                grid-template-columns: 1fr;
            }

            .container {
                padding: 20px;
            }

            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ FFT Analysis Tool</h1>
        <p class="subtitle">Upload a text file or image to compute its FFT and visualize the frequency spectrum</p>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('text')">üìÑ Text File</button>
            <button class="tab" onclick="switchTab('image')">üñºÔ∏è Image</button>
        </div>

        <!-- Text File Tab -->
        <div id="textTab" class="tab-content active">
            <div class="upload-section" id="textUploadSection">
                <label for="textFileInput" class="file-input-label">
                    üìÅ Choose Text File
                </label>
                <input type="file" id="textFileInput" accept=".txt">
                <div class="file-info" id="textFileInfo">No file selected</div>
            </div>

            <div style="text-align: center;">
                <button class="btn" id="processTextBtn" onclick="processTextFile()" disabled>Compute FFT</button>
            </div>
        </div>

        <!-- Image Tab -->
        <div id="imageTab" class="tab-content">
            <div class="upload-section" id="imageUploadSection">
                <label for="imageFileInput" class="file-input-label">
                    üñºÔ∏è Choose Image (JPEG, PNG, SVG)
                </label>
                <input type="file" id="imageFileInput" accept="image/jpeg,image/png,image/svg+xml,.jpg,.jpeg,.png,.svg">
                <div class="file-info" id="imageFileInfo">No image selected</div>
            </div>

            <div class="image-preview-container" id="imagePreviewContainer">
                <h3 style="margin-bottom: 10px; color: #667eea;">Image Preview:</h3>
                <img id="imagePreview" class="image-preview" alt="Preview">
                <div class="stats" style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Image dimensions:</strong> <span id="imageDimensions">-</span><br>
                    <strong>Data points:</strong> <span id="imageDataPoints">-</span> (one per pixel row)
                </div>
            </div>

            <div class="url-input-section">
                <h4>Or load image from URL:</h4>
                <div class="url-input-group">
                    <input type="url" id="imageUrlInput" class="url-input" placeholder="https://example.com/image.jpg">
                    <button class="btn" id="loadUrlBtn" onclick="loadImageFromUrl()">Load Image</button>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" id="processImageBtn" onclick="processImage()" disabled>Compute FFT from Image</button>
            </div>
        </div>

        <div class="status" id="status"></div>

        <div class="results-section" id="resultsSection">
            <div class="results-grid">
                <div class="result-card full-width" id="fftGraphCard">
                    <h3>FFT Magnitude Spectrum Graph</h3>
                    <div class="stats">
                        <strong>Frequency bins:</strong> <span id="magnitudeCount">-</span>
                    </div>
                    <canvas id="fftCanvas" class="fft-canvas"></canvas>
                </div>

                <div class="result-card">
                    <h3>Magnitude Spectrum Data</h3>
                    <div class="stats">
                        <strong>Frequency bins:</strong> <span id="magnitudeCount2">-</span>
                    </div>
                    <div class="preview" id="magnitudePreview"></div>
                    <button class="download-btn" onclick="downloadResults('magnitude')">Download Magnitude Results</button>
                </div>

                <div class="result-card">
                    <h3>Full FFT (Real/Imag)</h3>
                    <div class="stats">
                        <strong>Values:</strong> <span id="fullCount">-</span> (interleaved real/imag pairs)
                    </div>
                    <div class="preview" id="fullPreview"></div>
                    <button class="download-btn" onclick="downloadResults('full')">Download Full FFT</button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import init, { compute_fft, compute_fft_magnitude_from_string, parse_time_series_from_string, compute_fft_magnitude } from './pkg/rs_wasm_experiment.js';

        let wasmReady = false;
        let magnitudeResults = null;
        let fullFftResults = null;
        let currentMode = 'text';

        // Initialize WASM module
        const statusDiv = document.getElementById('status');
        statusDiv.className = 'status info';
        statusDiv.textContent = 'Loading WASM module...';
        
        init().then(() => {
            wasmReady = true;
            statusDiv.className = 'status success';
            statusDiv.textContent = '‚úì WASM module loaded successfully!';
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 2000);
        }).catch(err => {
            statusDiv.className = 'status error';
            statusDiv.textContent = 'Error loading WASM module: ' + err.message;
        });

        // Tab switching
        window.switchTab = function(tab) {
            currentMode = tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            if (tab === 'text') {
                document.querySelector('.tab:first-child').classList.add('active');
                document.getElementById('textTab').classList.add('active');
            } else {
                document.querySelector('.tab:last-child').classList.add('active');
                document.getElementById('imageTab').classList.add('active');
            }
        };

        // Text file handling
        const textFileInput = document.getElementById('textFileInput');
        const textFileInfo = document.getElementById('textFileInfo');
        const processTextBtn = document.getElementById('processTextBtn');
        const textUploadSection = document.getElementById('textUploadSection');

        textFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                textFileInfo.textContent = `Selected: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
                processTextBtn.disabled = false;
            } else {
                textFileInfo.textContent = 'No file selected';
                processTextBtn.disabled = true;
            }
        });

        setupDragAndDrop(textUploadSection, textFileInput, textFileInfo, processTextBtn, '.txt');

        // Image file handling
        const imageFileInput = document.getElementById('imageFileInput');
        const imageFileInfo = document.getElementById('imageFileInfo');
        const processImageBtn = document.getElementById('processImageBtn');
        const imageUploadSection = document.getElementById('imageUploadSection');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePreview = document.getElementById('imagePreview');
        const imageUrlInput = document.getElementById('imageUrlInput');
        const loadUrlBtn = document.getElementById('loadUrlBtn');
        let currentImageFile = null; // Store current image file/data

        imageFileInput.addEventListener('change', (e) => {
            handleImageSelection(e.target.files[0]);
        });

        // Allow Enter key to load URL
        imageUrlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loadImageFromUrl();
            }
        });

        setupDragAndDrop(imageUploadSection, imageFileInput, imageFileInfo, processImageBtn, ['image/jpeg', 'image/png', 'image/svg+xml', '.jpg', '.jpeg', '.png', '.svg']);

        function handleImageSelection(file) {
            if (!file) return;
            
            const isImage = file.type.startsWith('image/') || 
                           ['.jpg', '.jpeg', '.png', '.svg'].some(ext => file.name.toLowerCase().endsWith(ext));
            
            if (isImage) {
                currentImageFile = file;
                imageFileInfo.textContent = `Selected: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
                processImageBtn.disabled = false;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    imagePreview.src = e.target.result;
                    imagePreviewContainer.classList.add('active');
                    
                    // Update image info when loaded
                    imagePreview.onload = () => {
                        const width = imagePreview.naturalWidth;
                        const height = imagePreview.naturalHeight;
                        document.getElementById('imageDimensions').textContent = `${width} √ó ${height} pixels`;
                        document.getElementById('imageDataPoints').textContent = height.toLocaleString();
                        
                        // Show warning for very large images
                        if (height > 20000) {
                            showStatus(
                                `‚ö†Ô∏è Large image detected (${height.toLocaleString()} pixels height). Processing may be slow.`, 
                                'info'
                            );
                        } else if (height > 10000) {
                            showStatus(
                                `‚ÑπÔ∏è Image has ${height.toLocaleString()} pixel rows. Processing may take a moment.`, 
                                'info'
                            );
                            setTimeout(() => {
                                if (statusDiv.textContent.includes('pixel rows')) {
                                    statusDiv.style.display = 'none';
                                }
                            }, 3000);
                        }
                    };
                };
                reader.readAsDataURL(file);
            } else {
                showStatus('Please select a valid image file (JPEG, PNG, or SVG)', 'error');
                processImageBtn.disabled = true;
            }
        }

        // Load image from URL
        window.loadImageFromUrl = async function() {
            const url = imageUrlInput.value.trim();
            if (!url) {
                showStatus('Please enter an image URL', 'error');
                return;
            }

            // Validate URL format
            try {
                new URL(url);
            } catch (e) {
                showStatus('Please enter a valid URL', 'error');
                return;
            }

            loadUrlBtn.disabled = true;
            loadUrlBtn.textContent = 'Loading...';
            statusDiv.className = 'status info';
            statusDiv.textContent = 'Loading image from URL... <span class="loading"></span>';
            statusDiv.style.display = 'block';

            try {
                // Fetch the image
                const response = await fetch(url, { mode: 'cors' });
                if (!response.ok) {
                    throw new Error(`Failed to load image: ${response.status} ${response.statusText}`);
                }

                const blob = await response.blob();
                
                // Validate it's an image
                if (!blob.type.startsWith('image/')) {
                    // Try to determine from URL extension
                    const urlLower = url.toLowerCase();
                    if (!['.jpg', '.jpeg', '.png', '.svg', '.gif', '.webp'].some(ext => urlLower.includes(ext))) {
                        throw new Error('URL does not appear to point to an image file');
                    }
                }

                // Create a File object from the blob
                const fileName = url.split('/').pop().split('?')[0] || 'image.jpg';
                const file = new File([blob], fileName, { type: blob.type || 'image/jpeg' });
                
                // Use the same handling as file upload
                currentImageFile = file;
                imageFileInfo.textContent = `Loaded from URL: ${fileName} (${(blob.size / 1024).toFixed(2)} KB)`;
                processImageBtn.disabled = false;
                
                // Show preview
                const objectUrl = URL.createObjectURL(blob);
                imagePreview.src = objectUrl;
                imagePreviewContainer.classList.add('active');
                
                // Update image info when loaded
                imagePreview.onload = () => {
                    const width = imagePreview.naturalWidth;
                    const height = imagePreview.naturalHeight;
                    document.getElementById('imageDimensions').textContent = `${width} √ó ${height} pixels`;
                    document.getElementById('imageDataPoints').textContent = height.toLocaleString();
                    
                    // Show warning for very large images
                    if (height > 20000) {
                        showStatus(
                            `‚ö†Ô∏è Large image detected (${height.toLocaleString()} pixels height). Processing may be slow.`, 
                            'info'
                        );
                    } else if (height > 10000) {
                        showStatus(
                            `‚ÑπÔ∏è Image has ${height.toLocaleString()} pixel rows. Processing may take a moment.`, 
                            'info'
                        );
                        setTimeout(() => {
                            if (statusDiv.textContent.includes('pixel rows')) {
                                statusDiv.style.display = 'none';
                            }
                        }, 3000);
                    }
                };

                showStatus('‚úì Image loaded successfully from URL!', 'success');
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Error loading image from URL:', error);
                let errorMsg = error.message;
                
                // Handle CORS errors specifically
                if (errorMsg.includes('CORS') || errorMsg.includes('fetch') || errorMsg.includes('Failed to fetch')) {
                    errorMsg = 'Failed to load image. The server may not allow cross-origin requests (CORS). Try uploading the image file directly instead.';
                }
                
                showStatus('Error loading image: ' + errorMsg, 'error');
                processImageBtn.disabled = true;
                imagePreviewContainer.classList.remove('active');
                currentImageFile = null;
            } finally {
                loadUrlBtn.disabled = false;
                loadUrlBtn.textContent = 'Load Image';
            }
        };

        function setupDragAndDrop(uploadSection, fileInput, fileInfo, processBtn, acceptedTypes) {
            uploadSection.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadSection.classList.add('dragover');
            });

            uploadSection.addEventListener('dragleave', () => {
                uploadSection.classList.remove('dragover');
            });

            uploadSection.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadSection.classList.remove('dragover');
                
                const file = e.dataTransfer.files[0];
                const isAccepted = Array.isArray(acceptedTypes) 
                    ? acceptedTypes.some(type => file.name.toLowerCase().endsWith(type) || file.type === type)
                    : file.name.toLowerCase().endsWith(acceptedTypes);
                
                if (file && isAccepted) {
                    fileInput.files = e.dataTransfer.files;
                    if (fileInput.id === 'imageFileInput') {
                        handleImageSelection(file);
                    } else {
                        fileInfo.textContent = `Selected: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
                        processBtn.disabled = false;
                    }
                } else {
                    showStatus(`Please select a valid file`, 'error');
                }
            });
        }

        // Process text file
        window.processTextFile = async function() {
            if (!wasmReady) {
                showStatus('WASM module not ready yet. Please wait...', 'error');
                return;
            }

            const file = textFileInput.files[0];
            if (!file) {
                showStatus('Please select a file first', 'error');
                return;
            }

            statusDiv.className = 'status info';
            statusDiv.textContent = 'Processing file... <span class="loading"></span>';
            statusDiv.style.display = 'block';
            processTextBtn.disabled = true;

            try {
                const fileContent = await file.text();
                
                const timeSeries = parse_time_series_from_string(fileContent);
                if (timeSeries.length === 0) {
                    throw new Error('No valid data points found in file');
                }

                // Check data size and warn if too large
                const dataPoints = timeSeries.length;
                const MAX_RECOMMENDED = 1000000;
                const MAX_WARNING = 2000000;
                
                if (dataPoints > MAX_WARNING) {
                    const proceed = confirm(
                        `Warning: Large dataset detected (${dataPoints.toLocaleString()} data points).\n\n` +
                        `Processing may be slow or cause browser performance issues.\n\n` +
                        `Recommended maximum: ${MAX_RECOMMENDED.toLocaleString()} data points.\n\n` +
                        `Do you want to continue?`
                    );
                    if (!proceed) {
                        processTextBtn.disabled = false;
                        statusDiv.style.display = 'none';
                        return;
                    }
                } else if (dataPoints > MAX_RECOMMENDED) {
                    showStatus(
                        `‚ö†Ô∏è Processing large dataset (${dataPoints.toLocaleString()} points). This may take a while...`, 
                        'info'
                    );
                }

                const magnitude = compute_fft_magnitude_from_string(fileContent);
                const fullFft = compute_fft(timeSeries);

                magnitudeResults = magnitude;
                fullFftResults = fullFft;

                displayResults(magnitude, fullFft);
                showStatus(`‚úì Successfully processed ${dataPoints.toLocaleString()} data points!`, 'success');
                processTextBtn.disabled = false;

            } catch (error) {
                console.error('Error processing file:', error);
                let errorMsg = error.message;
                
                // Check for out-of-memory errors
                if (errorMsg.includes('memory') || errorMsg.includes('Memory') || errorMsg.includes('alloc')) {
                    errorMsg = 'File too large - ran out of memory. Try using a smaller file (recommended: <1M data points).';
                }
                
                showStatus('Error processing file: ' + errorMsg, 'error');
                processTextBtn.disabled = false;
            }
        };

        // Process image
        window.processImage = async function() {
            if (!wasmReady) {
                showStatus('WASM module not ready yet. Please wait...', 'error');
                return;
            }

            // Use currentImageFile (could be from file input or URL)
            const file = currentImageFile || imageFileInput.files[0];
            if (!file) {
                showStatus('Please select or load an image first', 'error');
                return;
            }

            statusDiv.className = 'status info';
            statusDiv.textContent = 'Processing image... <span class="loading"></span>';
            statusDiv.style.display = 'block';
            processImageBtn.disabled = true;

            try {
                const imageData = await loadImageToCanvas(file);
                const timeSeries = extractPixelData(imageData);
                
                if (timeSeries.length === 0) {
                    throw new Error('Failed to extract pixel data from image');
                }

                // Check data size and warn if too large
                const dataPoints = timeSeries.length;
                const MAX_RECOMMENDED = 1000000;
                const MAX_WARNING = 2000000;
                
                if (dataPoints > MAX_WARNING) {
                    const proceed = confirm(
                        `Warning: Large dataset detected (${dataPoints.toLocaleString()} data points).\n\n` +
                        `Processing may be slow or cause browser performance issues.\n\n` +
                        `Recommended maximum: ${MAX_RECOMMENDED.toLocaleString()} data points.\n\n` +
                        `Do you want to continue?`
                    );
                    if (!proceed) {
                        processImageBtn.disabled = false;
                        statusDiv.style.display = 'none';
                        return;
                    }
                } else if (dataPoints > MAX_RECOMMENDED) {
                    showStatus(
                        `‚ö†Ô∏è Processing large dataset (${dataPoints.toLocaleString()} points). This may take a while...`, 
                        'info'
                    );
                }

                const magnitude = compute_fft_magnitude(timeSeries);
                const fullFft = compute_fft(timeSeries);

                magnitudeResults = magnitude;
                fullFftResults = fullFft;

                displayResults(magnitude, fullFft);
                showStatus(`‚úì Successfully processed image (${dataPoints.toLocaleString()} data points)!`, 'success');
                processImageBtn.disabled = false;

            } catch (error) {
                console.error('Error processing image:', error);
                let errorMsg = error.message;
                
                // Check for out-of-memory errors
                if (errorMsg.includes('memory') || errorMsg.includes('Memory') || errorMsg.includes('alloc')) {
                    errorMsg = 'Image too large - ran out of memory. Try using a smaller image (recommended: <10,000 pixels height).';
                }
                
                showStatus('Error processing image: ' + errorMsg, 'error');
                processImageBtn.disabled = false;
            }
        };

        async function loadImageToCanvas(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                img.onload = () => {
                    // Set canvas size to match image
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Draw image to canvas
                    ctx.drawImage(img, 0, 0);
                    
                    // Get image data
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    resolve(imageData);
                };

                img.onerror = () => reject(new Error('Failed to load image'));

                if (file.type === 'image/svg+xml') {
                    // For SVG, read as text and create object URL
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const svgBlob = new Blob([e.target.result], { type: 'image/svg+xml' });
                        const url = URL.createObjectURL(svgBlob);
                        img.src = url;
                    };
                    reader.readAsText(file);
                } else {
                    img.src = URL.createObjectURL(file);
                }
            });
        }

        function extractPixelData(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            
            // Convert to grayscale and extract 1D signal
            // Strategy: Average all rows to get a representative 1D signal
            const pixelValues = [];
            
            for (let y = 0; y < height; y++) {
                let rowSum = 0;
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    // Convert to grayscale using standard formula
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    rowSum += gray;
                }
                // Average of the row, normalized to 0-1 range
                pixelValues.push(rowSum / width / 255.0);
            }
            
            return pixelValues;
        }

        function displayResults(magnitude, fullFft) {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.classList.add('active');

            // Update counts
            document.getElementById('magnitudeCount').textContent = magnitude.length;
            document.getElementById('magnitudeCount2').textContent = magnitude.length;
            document.getElementById('fullCount').textContent = fullFft.length;

            // Draw FFT graph
            drawFFTGraph(magnitude);

            // Text previews
            const magnitudePreview = magnitude.slice(0, 20).map(v => v.toFixed(6)).join('\n');
            if (magnitude.length > 20) {
                document.getElementById('magnitudePreview').textContent = magnitudePreview + '\n... (' + (magnitude.length - 20) + ' more values)';
            } else {
                document.getElementById('magnitudePreview').textContent = magnitudePreview;
            }

            const fullPreview = fullFft.slice(0, 20).map(v => v.toFixed(6)).join('\n');
            if (fullFft.length > 20) {
                document.getElementById('fullPreview').textContent = fullPreview + '\n... (' + (fullFft.length - 20) + ' more values)';
            } else {
                document.getElementById('fullPreview').textContent = fullPreview;
            }
        }

        function drawFFTGraph(magnitude) {
            const canvas = document.getElementById('fftCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            canvas.width = width * window.devicePixelRatio;
            canvas.height = height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            if (magnitude.length === 0) return;

            // Find max value for scaling
            const maxValue = Math.max(...magnitude);
            if (maxValue === 0) return;

            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // Draw FFT graph
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            ctx.beginPath();

            const stepX = width / (magnitude.length - 1);
            const padding = 20;

            for (let i = 0; i < magnitude.length; i++) {
                const x = i * stepX;
                const normalizedValue = magnitude[i] / maxValue;
                const y = height - padding - (normalizedValue * (height - 2 * padding));

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }

            ctx.stroke();

            // Draw axes labels
            ctx.fillStyle = '#666';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Frequency', width / 2, height - 5);
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Magnitude', 0, 0);
            ctx.restore();

            // Draw max value label
            ctx.fillStyle = '#667eea';
            ctx.textAlign = 'right';
            ctx.fillText(`Max: ${maxValue.toFixed(2)}`, width - 10, 15);
        }

        function showStatus(message, type) {
            statusDiv.className = `status ${type}`;
            statusDiv.innerHTML = message;
            statusDiv.style.display = 'block';
        }

        window.downloadResults = function(type) {
            let data, filename, content;

            if (type === 'magnitude' && magnitudeResults) {
                data = magnitudeResults;
                filename = 'fft_magnitude.txt';
            } else if (type === 'full' && fullFftResults) {
                data = fullFftResults;
                filename = 'fft_full.txt';
            } else {
                showStatus('No results available to download', 'error');
                return;
            }

            content = data.map(v => v.toString()).join('\n');

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`‚úì Downloaded ${filename}`, 'success');
            setTimeout(() => {
                if (statusDiv.textContent.includes('Downloaded')) {
                    statusDiv.style.display = 'none';
                }
            }, 2000);
        };
    </script>
</body>
</html>
